/*排列与组合是常用的数学方法，其中组合就是从 n 个元素中抽取 r 个（不分顺序且r ≤ n），为了简单起见，我们就认为是从前n个自然数（1,2,3...）中抽取r个
现在，给出n和r，要求你输出所有可能的组合比如 n = 4，r = 2 的时候有1 2,1 3,1 4,2 3,2 4,3 4,共6种情况
输入
一行，包含两个数n和r(1 < n < 21,0 ≤ r ≤ n)
输出
所有的组合情况，每一个组合占一行且其中的元素按由小到大的顺序排列，所有的组合也按字典顺序。*/
#define _CRT_SECURE_NO_WARNINGS

#include <cstdio>

#define _N 30

int n, r;

int ans[_N];

void print_ans() {
    for (int i = 1; i <= r; i++) {
        printf("%d ", ans[i]);
    }
    puts("");
}

//这个函数的作用是把 (1 ... cur_value) 中的部分数放进 ans 数组中，其中最大的数一定是 cur_value
void calc(int cur_val, int cur_pt) {
    if (cur_pt > r) {
        print_ans();
        return;//什么时候结束递归？如果当前位置 cur_pt 大于 r ，说明已经达到了最大允许的位置数，此时打印当前数字序列并返回，结束递归
    }
    if (cur_val > n) { 
        return;//什么时候结束递归？如果当前值 cur_val 大于 n ，说明已经超过了最大允许的值，此时直接返回，结束递归
    }
    ans[cur_pt] = cur_val;//否则，将当前值 cur_val 赋值给 ans[cur_pt]
    calc(cur_val + 1, cur_pt + 1);//然后，分别进行以下两种情况的递归调用: 1)将当前值加 1，位置加 1，继续递归; 2)将当前值加 1，位置不变，继续递归
    calc(cur_val + 1, cur_pt);//之所以写成这样的顺序，是由于题目的要求(先变后面的再变前面的)   
}/*此处的递归是基于这样的想法: 为了保证函数上述的作用，当 cur_val 变成 (cur_val + 1) 时，有 2 种选择可以使函数作用不变，而首选 1) 是由于题目的要求(顺序)
为什么不去考虑数目？因为这个数组的(有效)长度是固定的，而数组中数据的最大值是变化的，关键就在于怎么去控制它*/
//递归分为 3 个方面: 1) 什么时候结束递归？2) 两个递归之间要不要做点什么？3) 怎么递归？递归的目的就在于要保证函数的性质在参数发生变化时没有改变

int main() {
    scanf("%d%d", &n, &r);
    calc(1, 1);
    return 0;
}