/*
任务描述
小蓝鲸手上有两条纸带，每一条纸带上都有若干数字，现在小蓝鲸在思考将两个纸带拼接到一起。
由于第一条纸带的末尾和第二条纸带的开头可能有部分相同的子数列（如123和234就存在相同的部分23）
并且小蓝鲸想尽可能缩短拼接成的纸带的长度，对此小蓝鲸采取的方式是在拼接的过程中使得第一条纸带末尾和第二条纸袋开头相同的那一部分重合，从而最大限度的缩小最终的纸带的长度。

下面我们用几个例子来帮助大家理解题意。

举例：
第一条纸带上有5个数字，从头到尾依次为：12345
第二条纸带上有5个数字，从头到尾依次为：34567
则第一条纸带末尾和第二条纸带开头重合的部分为345，因此最终拼接而成的纸带上数字按顺序为1234567。

要注意的是，小蓝鲸想尽可能缩小纸带的长度，因此如果第一条纸带的末尾和第二条纸带的开头出现多种匹配的情况下，小蓝鲸会优先选择最长的匹配结果。
举例：
第一条纸带上有6个数字，从头到尾依次为：512312
第二条纸带上有6个数字，从头到尾依次为：123127
有两种匹配结果：12和12312，但小蓝鲸会选择最长的匹配结果：12312，所以最终拼接而成的纸带上的数字按顺序为5123127。

另外，如果小蓝鲸发现无法找到匹配的话，那么ta会直接将两条纸带拼在一起。
举例：
第一条纸带上有5个数字，从头到尾依次为：12345
第二条纸带上有5个数字，从头到尾依次为：67890
最终拼接而成的纸带为1234567890。

输入
第一行输入两个正整数m和n，分别代表第一条纸带和第二条纸带的长度，1≤m≤100，1≤n≤100。
第二行输入m个用空格隔开的正整数，代表第一条纸带上的m个数字，对于每个正整数k，均满足0≤k≤9。
第三行输入n个用空格隔开的正整数，代表第二条纸带上的n个数字，对于每个正整数k，均满足0≤k≤9。

输出
最终连接成的纸带上的数字，从开头到末尾依次输出，用空格隔开.*/
#include <iostream>
using namespace std;

int main()
{
    int m, n;
    cin >> m >> n;
    int nums_1[m];
    int nums_2[n];
    for (int i = 0; i < m; i++)
    {
        cin >> nums_1[i];
    }
    for (int i = 0; i < n; i++)
    {
        cin >> nums_2[i];
    }
    int mmin = m < n ? m : n;
    int judge = 1;
    int index = mmin - 1;// index ~ m-1 i~m-1-index+i
    while (index >= 0)
    {
        for (int i = 0; i <= index; i++)
        {
            if(nums_2[i] != nums_1[m-1-index+i])
            {
                index--;
                judge = 0;
                break;
            }
        }
        if (judge == 1)
        {
            break;
        }
        judge = 1;
    }
    for (int i = 0; i < m; i++)
    {
        cout << nums_1[i] << " ";
    }
    for (int i = index + 1; i < n; i++)
    {
        cout << nums_2[i] << " ";
    }
    return 0;
}